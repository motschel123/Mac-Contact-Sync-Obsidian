import { App, Notice, Platform, Plugin, PluginSettingTab, Setting, TFile, TFolder, normalizePath } from 'obsidian';
import { type } from 'os';
import { isFloat32Array } from 'util/types';
import VCardObject from './vcard-object';
const vCard = require('vcf');
const { spawn } = require('child_process');


interface ContactsPluginSettings {
	contactsGroup: string;
	fileNamePrefix: string;
	contactsFolder: string;
	autogenerationStartTag: string
	autogenerationStartText: string
	autogenerationEndTag: string
	autogenerationEndText: string
	enabledContactFields: string
}

class SettingTab extends PluginSettingTab {
	plugin: ContactsPlugin;

	constructor(app: App, plugin: ContactsPlugin) {
		super(app, plugin);
		this.plugin = plugin;
	}

	display(): void {
		const {containerEl} = this;

		containerEl.empty();

		new Setting(containerEl)
			.setName('Contacts folder')
			.setDesc('Select the folder in which your contacts will stored')
			.addText(text => text
				.setPlaceholder('Contacts')
				.setValue(this.plugin.settings.contactsFolder)
				.onChange(async (value) => {
					this.plugin.settings.contactsFolder = value;
					await this.plugin.saveSettings();
				}));
		
		new Setting(containerEl)
			.setName('File name prefix')
			.setDesc('Type a prefix for the files in while your contacts will be stored')
			.addText(text => text
				.setPlaceholder('')
				.setValue(this.plugin.settings.fileNamePrefix)
				.onChange(async (value) => {
					this.plugin.settings.fileNamePrefix = value;
					await this.plugin.saveSettings();
				}));
		
		new Setting(containerEl)
			.setName('Contacts group')
			.setDesc('Enter the name of the group ("Smart List") in which your contacts are stored in the MacOS Contacts app')
			.addText(text => text
				.setPlaceholder('Obsidian')
				.setValue(this.plugin.settings.contactsGroup)
				.onChange(async (value) => {
					this.plugin.settings.contactsGroup = value;
					await this.plugin.saveSettings();
				}));
		
		new Setting(containerEl)
			.setName('Configure the shown contact fields below')
			.setDesc('To update the shown contact fields, re-sync your contacts')

		for (let attribute of VCardObject.getVCardFields()) {
			new Setting(containerEl)
				.setName(attribute == "fn" ? 'Name heading' : `${attribute}`)
				.addToggle((toggle) => {
					toggle.setValue(this.plugin.settings.enabledContactFields.includes(attribute))
					toggle.onChange(async (value) => {
						this.plugin.settings.enabledContactFields = this.toggleEnabledField(attribute, value);
						await this.plugin.saveSettings();
						console.debug(this.plugin.settings.enabledContactFields)
					});
				});
		}
	}

	toggleEnabledField(field: string, value: boolean): string {
		let enabledFields = this.plugin.settings.enabledContactFields.split(',');
		if (value) {
			enabledFields.push(field);
		} else {
			enabledFields = enabledFields.filter((enabledField) => enabledField != field);
		}
		return enabledFields.join(',');
	}
}

const DEFAULT_SETTINGS: ContactsPluginSettings = {
	contactsGroup: 'Obsidian',
	contactsFolder: 'Contacts',
	fileNamePrefix: '',
	autogenerationStartTag: "START",
	autogenerationStartText: "Content BELOW this line is AUTOGENERATED and will be REPLACED.",
	autogenerationEndTag: "END",
	autogenerationEndText: "Content ABOVE this line is AUTOGENERATED and will be REPLACED.",
	enabledContactFields: 'fn,nickname,emails,title,organization,telephones,addresses,birthdate,URLs,notes'
}

export default class ContactsPlugin extends Plugin {
	settings: ContactsPluginSettings;

	async onload() {
		await this.loadSettings();

		// This adds a simple command that can be triggered anywhere
		this.addCommand({
			id: 'sync-contacts',
			name: 'Sync contacts',
			callback: async () =>  {
				if (!Platform.isMacOS) 
					return new Notice("Error: This plugin only works on MacOS");

				// Find/Create contacts folder
				if (await this.app.vault.adapter.exists(normalizePath(this.settings.contactsFolder)) == false)
					await this.app.vault.createFolder(this.settings.contactsFolder);

				new Notice('Syncing...')
				
				const loadContactsLogic = new LoadContactsLogic(this.settings)

				let numberOfFoundContacts = await loadContactsLogic.getNumberOfContactsInGroup();
				new Notice(`Found ${numberOfFoundContacts} Contacts in group ${this.settings.contactsGroup}`)

				// Load contacts from MacOS "Contacts"
				let markdownResults = await loadContactsLogic.loadContacts();
				// Save all contacts into file
				let successfulContacts = 0
				let promises: Array<Promise<any>> = [];
				for (let [filename, markdown] of markdownResults) {
					// Setup File
					let normPath = normalizePath(`${this.settings.contactsFolder}/${filename}.md`);
					let contactFile = this.app.vault.getAbstractFileByPath(normPath);
					let newContactInfo = `<!-- ${this.settings.autogenerationStartTag} ${this.settings.autogenerationStartText} --> \n${markdown} \n<!-- ${this.settings.autogenerationEndTag} ${this.settings.autogenerationEndText} -->`;
					
					// contactFile is a folder 
					if (contactFile instanceof TFolder) {
						console.error(`Error: ${filename} is a folder`);
						new Notice(`Error: ${filename} is a folder`);
					// contactFile doesn't exist yet
					} else if (contactFile === null) {
						promises.push(
							this.app.vault.create(normPath, newContactInfo)
							.then((_) => successfulContacts++)
							.catch((error) => console.error(`Error syncing ${filename}\n${error}`))
						);
					// contactFile exists
					} else if (contactFile instanceof TFile) {
						promises.push(
							// extract the old contact info and replace it with the new data
							this.app.vault.process(contactFile, (oldContent) => {
								let lines = oldContent.split("\n");
								
								let startReplacementIndex = lines.findIndex((line) => line.startsWith("<!-- " + this.settings.autogenerationStartTag));
								let endReplacementIndex = lines.findIndex((line) => line.startsWith("<!-- " + this.settings.autogenerationEndTag));

								let newLines = Array<string>();

								for (let i = Math.min(0, startReplacementIndex); i < lines.length; i++) {
									if (i == startReplacementIndex) {
										newLines.push(newContactInfo);
									} else if (i >= startReplacementIndex && i <= endReplacementIndex) {
										continue;
									} else {
										newLines.push(lines[i]);
									}
								}
								return newLines.join("\n");							
							})
							.then((_) => successfulContacts++)
							.catch((error) => console.error(`Error syncing ${filename}\n${error}`))
						);
					}
				}

				Promise.all(promises)
				.catch((error) => {
					new Notice("Error syncing contacts!");
					console.error(error);
				}).finally(() => {
					new Notice(`Successfully synced ${successfulContacts} of ${numberOfFoundContacts} Contacts`)
					console.info(`Successfully synced ${successfulContacts} of ${numberOfFoundContacts} Contacts`)
				});
			}
		});


		// This adds a settings tab so the user can configure various aspects of the plugin
		this.addSettingTab(new SettingTab(this.app, this));
	}

	async loadSettings() {
		this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
	}

	async saveSettings() {
		await this.saveData(this.settings);
	}
}

class LoadContactsLogic {
	constructor(
		private settings: ContactsPluginSettings
	) {
		this.settings = settings;
	}

	async loadContacts(): Promise<Map<string, string>> {
		let vCards: VCardObject[] = await this.getVCardStringsFromContactsApp();
		// Filter out vCards without names
		vCards = vCards.filter((vcard) => {
			return vcard.fn != undefined;
		});

		const filenameToMarkdown = new Map<string, string>();
		for (let vcard of vCards) {
			filenameToMarkdown.set(vcard.getFilename(this.settings.fileNamePrefix), vcard.toMarkdown(this.settings.enabledContactFields));
		}
		return filenameToMarkdown;
	}

	getNumberOfContactsInGroup(): Promise<number> {
		const groupName = this.settings.contactsGroup;
		const GROUP_NOT_DEFINED_ERROR = "GROUP NOT DEFINED";
		

		const JXA_SCRIPT = `
			let Contacts = Application('Contacts');
			Contacts.includeStandardAdditions = true;

			let groups = Contacts.groups.whose({ name: '${groupName}'});
			if (groups.length === 0 || groups === undefined || groups === null)
			 	throw new Error('${GROUP_NOT_DEFINED_ERROR}');

			groups[0].people.length;
		`;

		return new Promise((resolve, reject) => {
			// Start JXA Script
			const osascript = spawn('osascript', ['-l', 'JavaScript', '-e', JXA_SCRIPT]);
			
			// Handle JXA Script output (number of contacts in list)
			osascript.stdout.on('data', (data: number) => {
				resolve(data)
			});
	
			osascript.stderr.on('data', (data: Buffer) => {
				const errorMsg = data.toString('utf-8');

				if (errorMsg.includes(GROUP_NOT_DEFINED_ERROR)) {
					console.error(`Group "${groupName}" not found in Contacts app - JXA Script Error: ${errorMsg} `);
					reject(new Error(GROUP_NOT_DEFINED_ERROR));
					new Notice(`Error: Group "${groupName}" not found in Contacts app.`);
					return;
				}

				new Notice(`Error retrieving contacts: \n${data}`);
			});
		});
	}

	getVCardStringsFromContactsApp(): Promise<VCardObject[]> {
		const groupName = this.settings.contactsGroup;
		const GROUP_NOT_DEFINED_ERROR = "GROUP NOT DEFINED";
		const JXA_SCRIPT = `
			ObjC.import('Foundation');
			const stdout = $.NSFileHandle.fileHandleWithStandardOutput;

			let Contacts = Application('Contacts');
			Contacts.includeStandardAdditions = true;

			let groups = Contacts.groups.whose({ name: '${groupName}'});
			if (groups.length === 0 || groups === undefined || groups === null)
			 	throw new Error('${GROUP_NOT_DEFINED_ERROR}');

			for (let vcard of groups[0].people.vcard()) {
				// Write to stdout
				const nsString = $.NSString.alloc.initWithUTF8String(vcard);
				const data = nsString.dataUsingEncoding($.NSUTF8StringEncoding);
				stdout.writeData(data);
			}
		`;

		return new Promise<VCardObject[]>((resolve, reject) => {
			let vCardStrBuffer = "";
			const vCards: VCardObject[]= [];
			// Start JXA Script
			const osascript = spawn('osascript', ['-l', 'JavaScript', '-e', JXA_SCRIPT]);
			
			// Handle JXA Script output (vCard strings)
			osascript.stdout.on('data', (data: Buffer) => {
				vCardStrBuffer += data.toString('utf-8');
				// Check if vCard is complete
				const regex = /BEGIN:VCARD[\s\S]*?END:VCARD/g;
				const matches = vCardStrBuffer.match(regex);
				for (let match of matches ?? []) {
					const card = new vCard().parse(match);
					const vCardObj = new VCardObject(card);
					vCards.push(vCardObj);
				}
				vCardStrBuffer = vCardStrBuffer.replace(regex, "");
			});
			
			osascript.on('close', (code: any) => {
				if ((vCardStrBuffer = vCardStrBuffer.trim()).length > 0) {
					console.error(`JXA Script Error: Possibly Incomplete vCard: ${vCardStrBuffer}`);
					console.debug(`Leftover vCardBuffer Length: ${vCardStrBuffer.length}`);
				}
				console.debug(vCards)
				resolve(vCards);
			});
	
			osascript.stderr.on('data', (data: Buffer) => {
				const errorMsg = data.toString('utf-8');

				if (errorMsg.includes(GROUP_NOT_DEFINED_ERROR)) {
					console.error(`Group "${groupName}" not found in Contacts app - JXA Script Error: ${errorMsg} `);
					reject(new Error(GROUP_NOT_DEFINED_ERROR));
					new Notice(`Error: Group "${groupName}" not found in Contacts app.`);
					return;
				}

				new Notice(`Error retrieving contacts: \n${data}`);
			});
		});
	}
}
